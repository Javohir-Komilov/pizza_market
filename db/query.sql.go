// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addToCart = `-- name: AddToCart :exec
INSERT INTO cart_items (user_id, menu_item_id, quantity)
VALUES (?, ?, ?)
`

type AddToCartParams struct {
	UserID     int64
	MenuItemID int64
	Quantity   int64
}

func (q *Queries) AddToCart(ctx context.Context, arg AddToCartParams) error {
	_, err := q.db.ExecContext(ctx, addToCart, arg.UserID, arg.MenuItemID, arg.Quantity)
	return err
}

const clearCart = `-- name: ClearCart :exec
DELETE FROM cart_items WHERE user_id = ?
`

func (q *Queries) ClearCart(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, clearCart, userID)
	return err
}

const createMenuItem = `-- name: CreateMenuItem :one
INSERT INTO menu_items (name, description, price, image_url, category_id)
VALUES (?, ?, ?, ?, ?) RETURNING id, name, description, image_url, price, category_id
`

type CreateMenuItemParams struct {
	Name        string
	Description sql.NullString
	Price       float64
	ImageUrl    string
	CategoryID  sql.NullInt64
}

func (q *Queries) CreateMenuItem(ctx context.Context, arg CreateMenuItemParams) (MenuItem, error) {
	row := q.db.QueryRowContext(ctx, createMenuItem,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.ImageUrl,
		arg.CategoryID,
	)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.CategoryID,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_id, total_price, status)
VALUES (?, ?, ?) RETURNING id, user_id, total_price, status, created_at
`

type CreateOrderParams struct {
	UserID     int64
	TotalPrice float64
	Status     string
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder, arg.UserID, arg.TotalPrice, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalPrice,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (order_id, menu_item_id, quantity)
VALUES (?, ?, ?) RETURNING id, order_id, menu_item_id, quantity
`

type CreateOrderItemParams struct {
	OrderID    int64
	MenuItemID int64
	Quantity   int64
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRowContext(ctx, createOrderItem, arg.OrderID, arg.MenuItemID, arg.Quantity)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.MenuItemID,
		&i.Quantity,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (user_id, token, expires_at)
VALUES (?, ?, ?) RETURNING id, user_id, token, expires_at, created_at
`

type CreateSessionParams struct {
	UserID    int64
	Token     string
	ExpiresAt time.Time
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession, arg.UserID, arg.Token, arg.ExpiresAt)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, password, email, is_admin)
VALUES (?, ?, ?, ?) RETURNING id
`

type CreateUserParams struct {
	Username string
	Password string
	Email    string
	IsAdmin  int64
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.IsAdmin,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions WHERE expires_at <= CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredSessions)
	return err
}

const deleteMenuItem = `-- name: DeleteMenuItem :exec
DELETE FROM menu_items WHERE id = ?
`

func (q *Queries) DeleteMenuItem(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMenuItem, id)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE token = ?
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, token)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getCartItems = `-- name: GetCartItems :many
SELECT ci.id, ci.user_id, ci.menu_item_id, ci.quantity
FROM cart_items ci
JOIN menu_items mi ON ci.menu_item_id = mi.id
WHERE ci.user_id = ?
`

func (q *Queries) GetCartItems(ctx context.Context, userID int64) ([]CartItem, error) {
	rows, err := q.db.QueryContext(ctx, getCartItems, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CartItem
	for rows.Next() {
		var i CartItem
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MenuItemID,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategories = `-- name: GetCategories :many
SELECT id, title FROM categories
`

func (q *Queries) GetCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.ID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryById = `-- name: GetCategoryById :one
SELECT id, title FROM categories
WHERE id = ? LIMIT 1
`

func (q *Queries) GetCategoryById(ctx context.Context, id int64) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategoryById, id)
	var i Category
	err := row.Scan(&i.ID, &i.Title)
	return i, err
}

const getMenuItemById = `-- name: GetMenuItemById :one
SELECT id, name, description, image_url, price, category_id FROM menu_items WHERE id = ? LIMIT 1
`

func (q *Queries) GetMenuItemById(ctx context.Context, id int64) (MenuItem, error) {
	row := q.db.QueryRowContext(ctx, getMenuItemById, id)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.CategoryID,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one
SELECT id, user_id, total_price, status, created_at FROM orders WHERE id = ? LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, id int64) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalPrice,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT oi.id, oi.order_id, oi.menu_item_id, oi.quantity, mi.name, mi.price
FROM order_items oi
JOIN menu_items mi ON oi.menu_item_id = mi.id
WHERE oi.order_id = ?
`

type GetOrderItemsRow struct {
	ID         int64
	OrderID    int64
	MenuItemID int64
	Quantity   int64
	Name       string
	Price      float64
}

func (q *Queries) GetOrderItems(ctx context.Context, orderID int64) ([]GetOrderItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderItemsRow
	for rows.Next() {
		var i GetOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.MenuItemID,
			&i.Quantity,
			&i.Name,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT id, user_id, token, expires_at, created_at FROM sessions WHERE token = ? LIMIT 1
`

func (q *Queries) GetSessionByToken(ctx context.Context, token string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByToken, token)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, password, email, is_admin FROM users WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.IsAdmin,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, password, email, is_admin FROM users WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.IsAdmin,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password, email, is_admin FROM users WHERE username = ? LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.IsAdmin,
	)
	return i, err
}

const listAllOrders = `-- name: ListAllOrders :many
SELECT id, user_id, total_price, status, created_at FROM orders ORDER BY created_at DESC
`

func (q *Queries) ListAllOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listAllOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TotalPrice,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenuItems = `-- name: ListMenuItems :many
SELECT id, name, description, image_url, price, category_id FROM menu_items ORDER BY category_id, name
`

func (q *Queries) ListMenuItems(ctx context.Context) ([]MenuItem, error) {
	rows, err := q.db.QueryContext(ctx, listMenuItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByUser = `-- name: ListOrdersByUser :many
SELECT id, user_id, total_price, status, created_at FROM orders WHERE user_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListOrdersByUser(ctx context.Context, userID int64) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TotalPrice,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, password, email, is_admin FROM users ORDER BY id
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Email,
			&i.IsAdmin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFromCart = `-- name: RemoveFromCart :exec
DELETE FROM cart_items WHERE id = ? AND user_id = ?
`

type RemoveFromCartParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) RemoveFromCart(ctx context.Context, arg RemoveFromCartParams) error {
	_, err := q.db.ExecContext(ctx, removeFromCart, arg.ID, arg.UserID)
	return err
}

const updateCartItemQuantity = `-- name: UpdateCartItemQuantity :exec
UPDATE cart_items SET quantity = ? WHERE id = ? AND user_id = ?
`

type UpdateCartItemQuantityParams struct {
	Quantity int64
	ID       int64
	UserID   int64
}

func (q *Queries) UpdateCartItemQuantity(ctx context.Context, arg UpdateCartItemQuantityParams) error {
	_, err := q.db.ExecContext(ctx, updateCartItemQuantity, arg.Quantity, arg.ID, arg.UserID)
	return err
}

const updateMenuItem = `-- name: UpdateMenuItem :exec
UPDATE menu_items
SET name = ?, description = ?, price = ?, category_id = ?
WHERE id = ?
`

type UpdateMenuItemParams struct {
	Name        string
	Description sql.NullString
	Price       float64
	CategoryID  sql.NullInt64
	ID          int64
}

func (q *Queries) UpdateMenuItem(ctx context.Context, arg UpdateMenuItemParams) error {
	_, err := q.db.ExecContext(ctx, updateMenuItem,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.CategoryID,
		arg.ID,
	)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE orders SET status = ? WHERE id = ?
`

type UpdateOrderStatusParams struct {
	Status string
	ID     int64
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateOrderStatus, arg.Status, arg.ID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET email = ?
WHERE id = ?
`

type UpdateUserParams struct {
	Email string
	ID    int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser, arg.Email, arg.ID)
	return err
}
